# React State Management: Zero to Hero

A comprehensive guide to mastering state management in React, from basic concepts to advanced patterns.

---

## 1. State Concept

State represents data that changes over time in your application. When state changes, React re-renders the component to reflect the new data.

**Key principles:**

- State is local to a component by default
- Changing state triggers a re-render
- State updates may be asynchronous
- Never mutate state directly

```jsx
// State is data that changes
// When count changes, the UI updates
function Example() {
  const [count, setCount] = useState(0);

  return <div>{count}</div>; // Shows current count
}
```

---

## 2. useState

The fundamental hook for managing state in functional components.

```jsx
import { useState } from "react";

function Counter() {
  // Declare state variable with initial value
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setCount((c) => c - 1)}>
        Decrement (functional update)
      </button>
    </div>
  );
}
```

**Advanced useState patterns:**

```jsx
// Complex state object
const [user, setUser] = useState({
  name: "Alice",
  age: 25,
  email: "alice@example.com",
});

// Update nested state (always create new object)
const updateEmail = (newEmail) => {
  setUser((prev) => ({
    ...prev,
    email: newEmail,
  }));
};

// Lazy initialization (runs only once)
const [data, setData] = useState(() => {
  return expensiveComputation();
});

// Array state
const [items, setItems] = useState([]);

const addItem = (item) => {
  setItems((prev) => [...prev, item]);
};

const removeItem = (id) => {
  setItems((prev) => prev.filter((item) => item.id !== id));
};
```

---

## 3. Controlled Components

Components where form data is handled by React state rather than the DOM.

```jsx
function LoginForm() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log({ email, password });
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        placeholder="Email"
      />
      <input
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        placeholder="Password"
      />
      <button type="submit">Login</button>
    </form>
  );
}
```

**Multiple inputs pattern:**

```jsx
function FormWithMultipleInputs() {
  const [formData, setFormData] = useState({
    username: "",
    email: "",
    age: "",
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData((prev) => ({
      ...prev,
      [name]: value,
    }));
  };

  return (
    <form>
      <input
        name="username"
        value={formData.username}
        onChange={handleChange}
      />
      <input name="email" value={formData.email} onChange={handleChange} />
      <input name="age" value={formData.age} onChange={handleChange} />
    </form>
  );
}
```

---

## 4. Lifting State Up

Moving state to the closest common ancestor when multiple components need to share it.

```jsx
// Parent component holds shared state
function ParentComponent() {
  const [sharedValue, setSharedValue] = useState("");

  return (
    <div>
      <ChildA value={sharedValue} onChange={setSharedValue} />
      <ChildB value={sharedValue} />
    </div>
  );
}

// Child A can modify the state
function ChildA({ value, onChange }) {
  return <input value={value} onChange={(e) => onChange(e.target.value)} />;
}

// Child B reads the same state
function ChildB({ value }) {
  return <p>You typed: {value}</p>;
}
```

**Real-world example:**

```jsx
function TemperatureConverter() {
  const [celsius, setCelsius] = useState("");

  const fahrenheit = celsius ? ((celsius * 9) / 5 + 32).toFixed(2) : "";

  return (
    <div>
      <TemperatureInput
        scale="Celsius"
        temperature={celsius}
        onTemperatureChange={setCelsius}
      />
      <TemperatureInput
        scale="Fahrenheit"
        temperature={fahrenheit}
        onTemperatureChange={(f) => setCelsius((((f - 32) * 5) / 9).toFixed(2))}
      />
    </div>
  );
}

function TemperatureInput({ scale, temperature, onTemperatureChange }) {
  return (
    <fieldset>
      <legend>{scale}</legend>
      <input
        value={temperature}
        onChange={(e) => onTemperatureChange(e.target.value)}
      />
    </fieldset>
  );
}
```

---

## 5. Prop Drilling Pain

The problem of passing props through multiple layers of components.

```jsx
// ❌ Bad: Prop drilling through multiple levels
function App() {
  const [user, setUser] = useState({ name: "Alice" });

  return <Layout user={user} setUser={setUser} />;
}

function Layout({ user, setUser }) {
  return (
    <div>
      <Header user={user} setUser={setUser} />
    </div>
  );
}

function Header({ user, setUser }) {
  return (
    <nav>
      <UserMenu user={user} setUser={setUser} />
    </nav>
  );
}

function UserMenu({ user, setUser }) {
  return (
    <div>
      <span>{user.name}</span>
      <button onClick={() => setUser({ name: "Bob" })}>Change User</button>
    </div>
  );
}

// Problems:
// 1. Layout and Header don't use user/setUser but must pass them
// 2. Hard to maintain and refactor
// 3. Components are tightly coupled
```

---

## 6. Context

React's built-in solution for sharing state across the component tree without prop drilling.

```jsx
import { createContext, useContext, useState } from "react";

// 1. Create context
const UserContext = createContext();

// 2. Create provider component
function UserProvider({ children }) {
  const [user, setUser] = useState({ name: "Alice", role: "admin" });

  const value = {
    user,
    setUser,
    updateName: (name) => setUser((prev) => ({ ...prev, name })),
  };

  return <UserContext.Provider value={value}>{children}</UserContext.Provider>;
}

// 3. Create custom hook for consuming context
function useUser() {
  const context = useContext(UserContext);
  if (!context) {
    throw new Error("useUser must be used within UserProvider");
  }
  return context;
}

// 4. Use in components
function App() {
  return (
    <UserProvider>
      <Layout />
    </UserProvider>
  );
}

function Layout() {
  return <Header />; // No props needed!
}

function Header() {
  return <UserMenu />;
}

function UserMenu() {
  const { user, updateName } = useUser();

  return (
    <div>
      <span>{user.name}</span>
      <button onClick={() => updateName("Bob")}>Change Name</button>
    </div>
  );
}
```

**Multiple contexts pattern:**

```jsx
function App() {
  return (
    <UserProvider>
      <ThemeProvider>
        <CartProvider>
          <Layout />
        </CartProvider>
      </ThemeProvider>
    </UserProvider>
  );
}
```

**Context with useReducer: Complete Guide**

When your Context state becomes complex with multiple related values and actions, useReducer provides a more scalable pattern than multiple useState calls. It's like Redux but simpler and built into React.

**Why useReducer with Context?**

- Centralizes state logic in one place
- Makes state updates predictable and testable
- Easier to track what changes state and how
- Better for complex state with multiple sub-values
- Reduces bugs from scattered setState calls

**Basic Shopping Cart Example:**

```jsx
import { createContext, useContext, useReducer } from "react";

// 1. Create Context
const CartContext = createContext();

// 2. Define initial state
const initialState = {
  items: [],
  total: 0,
  itemCount: 0,
};

// 3. Create reducer function
function cartReducer(state, action) {
  switch (action.type) {
    case "ADD_ITEM": {
      const newItem = action.payload;
      const existingItem = state.items.find((item) => item.id === newItem.id);

      if (existingItem) {
        // Item exists, increase quantity
        return {
          ...state,
          items: state.items.map((item) =>
            item.id === newItem.id
              ? { ...item, quantity: item.quantity + 1 }
              : item
          ),
          total: state.total + newItem.price,
          itemCount: state.itemCount + 1,
        };
      } else {
        // New item
        return {
          ...state,
          items: [...state.items, { ...newItem, quantity: 1 }],
          total: state.total + newItem.price,
          itemCount: state.itemCount + 1,
        };
      }
    }

    case "REMOVE_ITEM": {
      const itemId = action.payload;
      const item = state.items.find((i) => i.id === itemId);

      if (!item) return state;

      if (item.quantity > 1) {
        // Decrease quantity
        return {
          ...state,
          items: state.items.map((i) =>
            i.id === itemId ? { ...i, quantity: i.quantity - 1 } : i
          ),
          total: state.total - item.price,
          itemCount: state.itemCount - 1,
        };
      } else {
        // Remove item completely
        return {
          ...state,
          items: state.items.filter((i) => i.id !== itemId),
          total: state.total - item.price,
          itemCount: state.itemCount - 1,
        };
      }
    }

    case "UPDATE_QUANTITY": {
      const { id, quantity } = action.payload;
      const item = state.items.find((i) => i.id === id);

      if (!item || quantity < 0) return state;

      const quantityDiff = quantity - item.quantity;

      if (quantity === 0) {
        return {
          ...state,
          items: state.items.filter((i) => i.id !== id),
          total: state.total - item.price * item.quantity,
          itemCount: state.itemCount - item.quantity,
        };
      }

      return {
        ...state,
        items: state.items.map((i) => (i.id === id ? { ...i, quantity } : i)),
        total: state.total + item.price * quantityDiff,
        itemCount: state.itemCount + quantityDiff,
      };
    }

    case "CLEAR_CART":
      return initialState;

    case "APPLY_DISCOUNT": {
      const discountPercent = action.payload;
      return {
        ...state,
        total: state.total * (1 - discountPercent / 100),
      };
    }

    default:
      throw new Error(`Unhandled action type: ${action.type}`);
  }
}

// 4. Create Provider component
function CartProvider({ children }) {
  const [state, dispatch] = useReducer(cartReducer, initialState);

  // Optional: Create helper functions
  const addItem = (item) => {
    dispatch({ type: "ADD_ITEM", payload: item });
  };

  const removeItem = (id) => {
    dispatch({ type: "REMOVE_ITEM", payload: id });
  };

  const updateQuantity = (id, quantity) => {
    dispatch({ type: "UPDATE_QUANTITY", payload: { id, quantity } });
  };

  const clearCart = () => {
    dispatch({ type: "CLEAR_CART" });
  };

  const applyDiscount = (percent) => {
    dispatch({ type: "APPLY_DISCOUNT", payload: percent });
  };

  const value = {
    state,
    dispatch,
    // Helper functions (optional but cleaner to use)
    addItem,
    removeItem,
    updateQuantity,
    clearCart,
    applyDiscount,
  };

  return <CartContext.Provider value={value}>{children}</CartContext.Provider>;
}

// 5. Create custom hook
function useCart() {
  const context = useContext(CartContext);
  if (context === undefined) {
    throw new Error("useCart must be used within CartProvider");
  }
  return context;
}

// 6. Export everything
export { CartProvider, useCart };
```

**Using the Cart Context:**

```jsx
// App.jsx
function App() {
  return (
    <CartProvider>
      <ShoppingApp />
    </CartProvider>
  );
}

// ProductList.jsx
function ProductList() {
  const { addItem } = useCart();

  const products = [
    { id: 1, name: "Laptop", price: 999 },
    { id: 2, name: "Mouse", price: 29 },
    { id: 3, name: "Keyboard", price: 79 },
  ];

  return (
    <div>
      <h2>Products</h2>
      {products.map((product) => (
        <div key={product.id}>
          <h3>{product.name}</h3>
          <p>${product.price}</p>
          <button onClick={() => addItem(product)}>Add to Cart</button>
        </div>
      ))}
    </div>
  );
}

// Cart.jsx
function Cart() {
  const { state, removeItem, updateQuantity, clearCart, applyDiscount } =
    useCart();

  return (
    <div>
      <h2>Shopping Cart</h2>
      <p>Items: {state.itemCount}</p>
      <p>Total: ${state.total.toFixed(2)}</p>

      {state.items.map((item) => (
        <div key={item.id}>
          <h3>{item.name}</h3>
          <p>Price: ${item.price}</p>
          <p>Quantity: {item.quantity}</p>
          <input
            type="number"
            value={item.quantity}
            onChange={(e) => updateQuantity(item.id, parseInt(e.target.value))}
            min="0"
          />
          <button onClick={() => removeItem(item.id)}>Remove One</button>
        </div>
      ))}

      <button onClick={() => applyDiscount(10)}>Apply 10% Discount</button>
      <button onClick={clearCart}>Clear Cart</button>
    </div>
  );
}
```

**Advanced: Authentication System with useReducer**

A real-world authentication flow with loading states, errors, and user data:

```jsx
import { createContext, useContext, useReducer, useEffect } from "react";

const AuthContext = createContext();

const initialState = {
  user: null,
  token: null,
  isAuthenticated: false,
  isLoading: true,
  error: null,
};

function authReducer(state, action) {
  switch (action.type) {
    case "AUTH_START":
      return {
        ...state,
        isLoading: true,
        error: null,
      };

    case "LOGIN_SUCCESS":
      return {
        ...state,
        user: action.payload.user,
        token: action.payload.token,
        isAuthenticated: true,
        isLoading: false,
        error: null,
      };

    case "LOGIN_FAILURE":
      return {
        ...state,
        user: null,
        token: null,
        isAuthenticated: false,
        isLoading: false,
        error: action.payload,
      };

    case "LOGOUT":
      return {
        ...initialState,
        isLoading: false,
      };

    case "UPDATE_USER":
      return {
        ...state,
        user: { ...state.user, ...action.payload },
      };

    case "RESTORE_SESSION":
      return {
        ...state,
        user: action.payload.user,
        token: action.payload.token,
        isAuthenticated: true,
        isLoading: false,
      };

    case "CLEAR_ERROR":
      return {
        ...state,
        error: null,
      };

    default:
      return state;
  }
}

function AuthProvider({ children }) {
  const [state, dispatch] = useReducer(authReducer, initialState);

  // Restore session on mount
  useEffect(() => {
    const token = localStorage.getItem("token");
    const user = localStorage.getItem("user");

    if (token && user) {
      dispatch({
        type: "RESTORE_SESSION",
        payload: { token, user: JSON.parse(user) },
      });
    } else {
      dispatch({ type: "LOGOUT" });
    }
  }, []);

  // Login function
  const login = async (email, password) => {
    dispatch({ type: "AUTH_START" });

    try {
      const response = await fetch("/api/login", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email, password }),
      });

      if (!response.ok) {
        throw new Error("Invalid credentials");
      }

      const data = await response.json();

      // Save to localStorage
      localStorage.setItem("token", data.token);
      localStorage.setItem("user", JSON.stringify(data.user));

      dispatch({
        type: "LOGIN_SUCCESS",
        payload: { user: data.user, token: data.token },
      });

      return { success: true };
    } catch (error) {
      dispatch({
        type: "LOGIN_FAILURE",
        payload: error.message,
      });
      return { success: false, error: error.message };
    }
  };

  // Register function
  const register = async (userData) => {
    dispatch({ type: "AUTH_START" });

    try {
      const response = await fetch("/api/register", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(userData),
      });

      if (!response.ok) {
        throw new Error("Registration failed");
      }

      const data = await response.json();

      localStorage.setItem("token", data.token);
      localStorage.setItem("user", JSON.stringify(data.user));

      dispatch({
        type: "LOGIN_SUCCESS",
        payload: { user: data.user, token: data.token },
      });

      return { success: true };
    } catch (error) {
      dispatch({
        type: "LOGIN_FAILURE",
        payload: error.message,
      });
      return { success: false, error: error.message };
    }
  };

  // Logout function
  const logout = () => {
    localStorage.removeItem("token");
    localStorage.removeItem("user");
    dispatch({ type: "LOGOUT" });
  };

  // Update user profile
  const updateUser = (userData) => {
    const updatedUser = { ...state.user, ...userData };
    localStorage.setItem("user", JSON.stringify(updatedUser));
    dispatch({ type: "UPDATE_USER", payload: userData });
  };

  const clearError = () => {
    dispatch({ type: "CLEAR_ERROR" });
  };

  const value = {
    ...state,
    login,
    register,
    logout,
    updateUser,
    clearError,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error("useAuth must be used within AuthProvider");
  }
  return context;
}

export { AuthProvider, useAuth };
```

**Using the Auth Context:**

```jsx
// LoginForm.jsx
function LoginForm() {
  const { login, isLoading, error, clearError } = useAuth();
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");

  useEffect(() => {
    return () => clearError(); // Clear error on unmount
  }, [clearError]);

  const handleSubmit = async (e) => {
    e.preventDefault();
    const result = await login(email, password);

    if (result.success) {
      // Redirect or show success message
      console.log("Login successful!");
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      {error && <div className="error">{error}</div>}

      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        disabled={isLoading}
      />

      <input
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        disabled={isLoading}
      />

      <button type="submit" disabled={isLoading}>
        {isLoading ? "Logging in..." : "Login"}
      </button>
    </form>
  );
}

// ProtectedRoute.jsx
function ProtectedRoute({ children }) {
  const { isAuthenticated, isLoading } = useAuth();

  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (!isAuthenticated) {
    return <Navigate to="/login" />;
  }

  return children;
}

// UserProfile.jsx
function UserProfile() {
  const { user, updateUser, logout } = useAuth();
  const [name, setName] = useState(user?.name || "");

  const handleUpdate = () => {
    updateUser({ name });
  };

  return (
    <div>
      <h2>Welcome, {user?.name}</h2>
      <input value={name} onChange={(e) => setName(e.target.value)} />
      <button onClick={handleUpdate}>Update Name</button>
      <button onClick={logout}>Logout</button>
    </div>
  );
}
```

**Key Benefits of useReducer with Context:**

1. **Centralized Logic**: All state transitions in one place
2. **Predictable**: Easy to understand what changes state
3. **Testable**: Reducers are pure functions, easy to test
4. **Scalable**: Add new actions without cluttering components
5. **Debug-friendly**: Clear action types help track state changes
6. **Type-safe**: Works great with TypeScript for action types

---

## 7. Zustand

A lightweight, modern state management library with minimal boilerplate.

**Installation:**

```bash
npm install zustand
```

**Basic usage:**

```jsx
import { create } from "zustand";

// Create store
const useStore = create((set) => ({
  // State
  count: 0,
  user: null,

  // Actions
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
  setUser: (user) => set({ user }),
  reset: () => set({ count: 0, user: null }),
}));

// Use in components
function Counter() {
  const count = useStore((state) => state.count);
  const increment = useStore((state) => state.increment);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}

function UserProfile() {
  const user = useStore((state) => state.user);
  const setUser = useStore((state) => state.setUser);

  return <div>{user ? <p>Hello, {user.name}</p> : <p>Not logged in</p>}</div>;
}
```

**Advanced Zustand Patterns: Complete Guide**

Zustand shines when you need advanced features while keeping your code simple. Let's explore powerful patterns for real-world applications.

---

### 1. Async Actions with Loading States

Handle API calls with proper loading and error states:

```jsx
import { create } from "zustand";

const usePostStore = create((set, get) => ({
  posts: [],
  loading: false,
  error: null,
  selectedPost: null,

  // Fetch all posts
  fetchPosts: async () => {
    set({ loading: true, error: null });
    try {
      const res = await fetch("https://api.example.com/posts");
      if (!res.ok) throw new Error("Failed to fetch posts");
      const posts = await res.json();
      set({ posts, loading: false });
    } catch (error) {
      set({ error: error.message, loading: false });
    }
  },

  // Fetch single post
  fetchPost: async (id) => {
    set({ loading: true, error: null });
    try {
      const res = await fetch(`https://api.example.com/posts/${id}`);
      if (!res.ok) throw new Error("Post not found");
      const post = await res.json();
      set({ selectedPost: post, loading: false });
    } catch (error) {
      set({ error: error.message, loading: false });
    }
  },

  // Create post with optimistic update
  createPost: async (newPost) => {
    const tempId = `temp-${Date.now()}`;
    const optimisticPost = { ...newPost, id: tempId };

    // Optimistically add to UI
    set((state) => ({
      posts: [...state.posts, optimisticPost],
    }));

    try {
      const res = await fetch("https://api.example.com/posts", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(newPost),
      });

      if (!res.ok) throw new Error("Failed to create post");
      const createdPost = await res.json();

      // Replace temp post with real one
      set((state) => ({
        posts: state.posts.map((p) => (p.id === tempId ? createdPost : p)),
      }));
    } catch (error) {
      // Rollback on error
      set((state) => ({
        posts: state.posts.filter((p) => p.id !== tempId),
        error: error.message,
      }));
    }
  },

  // Delete with optimistic update
  deletePost: async (id) => {
    const previousPosts = get().posts;

    // Optimistically remove
    set((state) => ({
      posts: state.posts.filter((p) => p.id !== id),
    }));

    try {
      const res = await fetch(`https://api.example.com/posts/${id}`, {
        method: "DELETE",
      });

      if (!res.ok) throw new Error("Failed to delete");
    } catch (error) {
      // Rollback on error
      set({
        posts: previousPosts,
        error: error.message,
      });
    }
  },

  // Clear error
  clearError: () => set({ error: null }),
}));

// Using in component
function PostsList() {
  const { posts, loading, error, fetchPosts, deletePost, clearError } =
    usePostStore();

  useEffect(() => {
    fetchPosts();
  }, [fetchPosts]);

  if (loading) return <div>Loading...</div>;
  if (error)
    return (
      <div>
        Error: {error} <button onClick={clearError}>Dismiss</button>
      </div>
    );

  return (
    <div>
      {posts.map((post) => (
        <div key={post.id}>
          <h3>{post.title}</h3>
          <button onClick={() => deletePost(post.id)}>Delete</button>
        </div>
      ))}
    </div>
  );
}
```

---

### 2. Slices Pattern (Modular Store Architecture)

Organize large stores by splitting into feature slices:

```jsx
import { create } from "zustand";

// User slice
const createUserSlice = (set, get) => ({
  user: null,
  isAuthenticated: false,

  setUser: (user) =>
    set({
      user,
      isAuthenticated: !!user,
    }),

  updateUser: (updates) =>
    set((state) => ({
      user: state.user ? { ...state.user, ...updates } : null,
    })),

  logout: () =>
    set({
      user: null,
      isAuthenticated: false,
    }),

  // Access other slices with get()
  getUserCartTotal: () => {
    const { user } = get();
    const { items } = get();
    return user ? items.reduce((sum, item) => sum + item.price, 0) : 0;
  },
});

// Cart slice
const createCartSlice = (set, get) => ({
  items: [],

  addItem: (item) =>
    set((state) => {
      const existing = state.items.find((i) => i.id === item.id);
      if (existing) {
        return {
          items: state.items.map((i) =>
            i.id === item.id ? { ...i, quantity: i.quantity + 1 } : i
          ),
        };
      }
      return { items: [...state.items, { ...item, quantity: 1 }] };
    }),

  removeItem: (id) =>
    set((state) => ({
      items: state.items.filter((i) => i.id !== id),
    })),

  clearCart: () => set({ items: [] }),

  getTotalPrice: () => {
    const { items } = get();
    return items.reduce((sum, item) => sum + item.price * item.quantity, 0);
  },

  getTotalItems: () => {
    const { items } = get();
    return items.reduce((sum, item) => sum + item.quantity, 0);
  },
});

// UI slice
const createUISlice = (set) => ({
  theme: "light",
  sidebarOpen: false,
  notifications: [],

  toggleTheme: () =>
    set((state) => ({
      theme: state.theme === "light" ? "dark" : "light",
    })),

  toggleSidebar: () =>
    set((state) => ({
      sidebarOpen: !state.sidebarOpen,
    })),

  addNotification: (message) =>
    set((state) => ({
      notifications: [
        ...state.notifications,
        {
          id: Date.now(),
          message,
          timestamp: new Date(),
        },
      ],
    })),

  removeNotification: (id) =>
    set((state) => ({
      notifications: state.notifications.filter((n) => n.id !== id),
    })),
});

// Combine all slices
const useStore = create((set, get) => ({
  ...createUserSlice(set, get),
  ...createCartSlice(set, get),
  ...createUISlice(set, get),
}));

// Usage in components
function CartSummary() {
  const items = useStore((state) => state.items);
  const getTotalPrice = useStore((state) => state.getTotalPrice);
  const getTotalItems = useStore((state) => state.getTotalItems);

  return (
    <div>
      <p>Items: {getTotalItems()}</p>
      <p>Total: ${getTotalPrice().toFixed(2)}</p>
    </div>
  );
}

function UserHeader() {
  const user = useStore((state) => state.user);
  const logout = useStore((state) => state.logout);
  const getUserCartTotal = useStore((state) => state.getUserCartTotal);

  return (
    <div>
      {user ? (
        <>
          <span>Welcome, {user.name}!</span>
          <span>Cart Total: ${getUserCartTotal().toFixed(2)}</span>
          <button onClick={logout}>Logout</button>
        </>
      ) : (
        <span>Please login</span>
      )}
    </div>
  );
}
```

---

### 3. Persist Middleware (localStorage/sessionStorage)

Save state to browser storage automatically:

```jsx
import { create } from "zustand";
import { persist, createJSONStorage } from "zustand/middleware";

// Basic persistence
const useAuthStore = create(
  persist(
    (set) => ({
      user: null,
      token: null,

      login: (user, token) => set({ user, token }),
      logout: () => set({ user: null, token: null }),
    }),
    {
      name: "auth-storage", // localStorage key
    }
  )
);

// Advanced persistence with custom storage
const useSettingsStore = create(
  persist(
    (set) => ({
      theme: "light",
      language: "en",
      notifications: true,

      setTheme: (theme) => set({ theme }),
      setLanguage: (language) => set({ language }),
      toggleNotifications: () =>
        set((state) => ({
          notifications: !state.notifications,
        })),
    }),
    {
      name: "app-settings",
      storage: createJSONStorage(() => sessionStorage), // Use sessionStorage

      // Partial persistence - only save specific keys
      partialize: (state) => ({
        theme: state.theme,
        language: state.language,
        // notifications excluded - won't persist
      }),

      // Migrate old versions
      version: 1,
      migrate: (persistedState, version) => {
        if (version === 0) {
          // Migrate from v0 to v1
          return {
            ...persistedState,
            language: persistedState.lang || "en",
          };
        }
        return persistedState;
      },

      // Custom serialization
      serialize: (state) => JSON.stringify(state),
      deserialize: (str) => JSON.parse(str),

      // Hydration callback
      onRehydrateStorage: (state) => {
        console.log("Hydration starts");

        return (state, error) => {
          if (error) {
            console.log("Error during hydration", error);
          } else {
            console.log("Hydration finished", state);
          }
        };
      },
    }
  )
);

// Multi-tab sync example
const useCartStore = create(
  persist(
    (set, get) => ({
      items: [],

      addItem: (item) =>
        set((state) => ({
          items: [...state.items, item],
        })),

      // Will sync across tabs automatically
      clearCart: () => set({ items: [] }),
    }),
    {
      name: "shopping-cart",
      // Syncs across tabs/windows
      storage: createJSONStorage(() => localStorage),
    }
  )
);
```

---

### 4. Immer Middleware (Mutable Syntax)

Write simpler updates with direct mutations (Immer handles immutability):

```jsx
import { create } from "zustand";
import { immer } from "zustand/middleware/immer";

const useStore = create(
  immer((set) => ({
    user: {
      name: "Alice",
      profile: {
        bio: "Developer",
        settings: {
          theme: "dark",
          notifications: {
            email: true,
            push: false,
          },
        },
      },
    },

    // Without Immer - complex immutable update
    // updateThemeOldWay: (theme) => set((state) => ({
    //   user: {
    //     ...state.user,
    //     profile: {
    //       ...state.user.profile,
    //       settings: {
    //         ...state.user.profile.settings,
    //         theme
    //       }
    //     }
    //   }
    // })),

    // With Immer - simple mutation
    updateTheme: (theme) =>
      set((state) => {
        state.user.profile.settings.theme = theme;
      }),

    toggleEmailNotifications: () =>
      set((state) => {
        state.user.profile.settings.notifications.email =
          !state.user.profile.settings.notifications.email;
      }),

    updateBio: (bio) =>
      set((state) => {
        state.user.profile.bio = bio;
      }),

    // Complex nested array mutations
    posts: [],

    addPost: (post) =>
      set((state) => {
        state.posts.push(post);
      }),

    updatePost: (id, updates) =>
      set((state) => {
        const post = state.posts.find((p) => p.id === id);
        if (post) {
          Object.assign(post, updates);
        }
      }),

    deletePost: (id) =>
      set((state) => {
        const index = state.posts.findIndex((p) => p.id === id);
        if (index !== -1) {
          state.posts.splice(index, 1);
        }
      }),
  }))
);

// Combining Immer with Persist
const useTodoStore = create(
  persist(
    immer((set) => ({
      todos: [],

      addTodo: (text) =>
        set((state) => {
          state.todos.push({
            id: Date.now(),
            text,
            completed: false,
          });
        }),

      toggleTodo: (id) =>
        set((state) => {
          const todo = state.todos.find((t) => t.id === id);
          if (todo) {
            todo.completed = !todo.completed;
          }
        }),

      deleteTodo: (id) =>
        set((state) => {
          const index = state.todos.findIndex((t) => t.id === id);
          if (index !== -1) {
            state.todos.splice(index, 1);
          }
        }),
    })),
    {
      name: "todos-storage",
    }
  )
);
```

---

### 5. Subscriptions & External Updates

React to store changes outside components:

```jsx
import { create } from "zustand";
import { subscribeWithSelector } from "zustand/middleware";

const useStore = create(
  subscribeWithSelector((set) => ({
    count: 0,
    user: null,
    theme: "light",

    increment: () => set((state) => ({ count: state.count + 1 })),
    setUser: (user) => set({ user }),
    setTheme: (theme) => set({ theme }),
  }))
);

// Subscribe to specific state changes
const unsubCount = useStore.subscribe(
  (state) => state.count,
  (count, prevCount) => {
    console.log("Count changed from", prevCount, "to", count);

    // Trigger side effects
    if (count > 10) {
      console.log("Count exceeded 10!");
    }
  }
);

// Subscribe to user login/logout
const unsubUser = useStore.subscribe(
  (state) => state.user,
  (user, prevUser) => {
    if (user && !prevUser) {
      console.log("User logged in:", user.name);
      // Track analytics
      // analytics.track('user_login', { userId: user.id });
    } else if (!user && prevUser) {
      console.log("User logged out");
      // Clear user data
    }
  }
);

// Subscribe to theme changes and update document
useStore.subscribe(
  (state) => state.theme,
  (theme) => {
    document.documentElement.setAttribute("data-theme", theme);
  }
);

// Cleanup subscriptions
// unsubCount();
// unsubUser();

// Subscribe to entire store
const unsubAll = useStore.subscribe((state) => {
  console.log("State changed:", state);
});
```

---

### 6. DevTools Integration

Debug your Zustand store like Redux:

```jsx
import { create } from "zustand";
import { devtools } from "zustand/middleware";

const useStore = create(
  devtools(
    (set) => ({
      count: 0,
      user: null,

      increment: () =>
        set(
          (state) => ({ count: state.count + 1 }),
          false, // don't replace state
          "increment" // action name in devtools
        ),

      setUser: (user) =>
        set(
          { user },
          false,
          { type: "setUser", user } // detailed action
        ),
    }),
    {
      name: "MyAppStore", // Store name in devtools
      enabled: process.env.NODE_ENV === "development",
    }
  )
);
```

---

### 7. Computed Values (Selectors)

Create derived state efficiently:

```jsx
import { create } from "zustand";

const useStore = create((set, get) => ({
  items: [],
  taxRate: 0.1,

  addItem: (item) =>
    set((state) => ({
      items: [...state.items, item],
    })),

  // Computed values as functions
  getSubtotal: () => {
    const { items } = get();
    return items.reduce((sum, item) => sum + item.price * item.quantity, 0);
  },

  getTax: () => {
    const { getSubtotal, taxRate } = get();
    return getSubtotal() * taxRate;
  },

  getTotal: () => {
    const { getSubtotal, getTax } = get();
    return getSubtotal() + getTax();
  },
}));

// Use in component
function CartTotal() {
  const getSubtotal = useStore((state) => state.getSubtotal);
  const getTax = useStore((state) => state.getTax);
  const getTotal = useStore((state) => state.getTotal);

  return (
    <div>
      <p>Subtotal: ${getSubtotal().toFixed(2)}</p>
      <p>Tax: ${getTax().toFixed(2)}</p>
      <p>Total: ${getTotal().toFixed(2)}</p>
    </div>
  );
}

// Alternative: Selector pattern with useMemo in component
function CartTotalOptimized() {
  const items = useStore((state) => state.items);
  const taxRate = useStore((state) => state.taxRate);

  const subtotal = useMemo(
    () => items.reduce((sum, item) => sum + item.price * item.quantity, 0),
    [items]
  );

  const tax = subtotal * taxRate;
  const total = subtotal + tax;

  return (
    <div>
      <p>Subtotal: ${subtotal.toFixed(2)}</p>
      <p>Tax: ${tax.toFixed(2)}</p>
      <p>Total: ${total.toFixed(2)}</p>
    </div>
  );
}
```

---

### 8. Combining Multiple Middlewares

Stack middlewares for maximum power:

```jsx
import { create } from "zustand";
import { persist, createJSONStorage } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";
import { devtools } from "zustand/middleware";

const useStore = create(
  devtools(
    persist(
      immer((set) => ({
        user: null,
        items: [],

        login: (user) =>
          set((state) => {
            state.user = user;
          }),

        addItem: (item) =>
          set((state) => {
            state.items.push(item);
          }),
      })),
      {
        name: "app-storage",
        storage: createJSONStorage(() => localStorage),
      }
    ),
    { name: "MyStore" }
  )
);
```

These advanced patterns make Zustand incredibly powerful while maintaining simplicity!

---

## 8. Redux Toolkit

The official, opinionated toolset for Redux that simplifies setup and common patterns.

**Installation:**

```bash
npm install @reduxjs/toolkit react-redux
```

**Setup:**

```jsx
// store.js
import { configureStore } from "@reduxjs/toolkit";
import counterReducer from "./counterSlice";
import userReducer from "./userSlice";

export const store = configureStore({
  reducer: {
    counter: counterReducer,
    user: userReducer,
  },
});

// App.jsx
import { Provider } from "react-redux";
import { store } from "./store";

function App() {
  return (
    <Provider store={store}>
      <YourApp />
    </Provider>
  );
}
```

**Creating slices:**

```jsx
// counterSlice.js
import { createSlice } from "@reduxjs/toolkit";

const counterSlice = createSlice({
  name: "counter",
  initialState: {
    value: 0,
    history: [],
  },
  reducers: {
    increment: (state) => {
      // Redux Toolkit uses Immer, so we can "mutate" state
      state.value += 1;
      state.history.push(state.value);
    },
    decrement: (state) => {
      state.value -= 1;
      state.history.push(state.value);
    },
    incrementByAmount: (state, action) => {
      state.value += action.payload;
      state.history.push(state.value);
    },
    reset: (state) => {
      state.value = 0;
      state.history = [];
    },
  },
});

export const { increment, decrement, incrementByAmount, reset } =
  counterSlice.actions;
export default counterSlice.reducer;

// Using in components
import { useSelector, useDispatch } from "react-redux";
import { increment, decrement, incrementByAmount } from "./counterSlice";

function Counter() {
  const count = useSelector((state) => state.counter.value);
  const history = useSelector((state) => state.counter.history);
  const dispatch = useDispatch();

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => dispatch(increment())}>+</button>
      <button onClick={() => dispatch(decrement())}>-</button>
      <button onClick={() => dispatch(incrementByAmount(5))}>+5</button>
      <p>History: {history.join(", ")}</p>
    </div>
  );
}
```

**Async thunks:**

```jsx
// userSlice.js
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";

// Async action
export const fetchUser = createAsyncThunk("user/fetchUser", async (userId) => {
  const response = await fetch(`https://api.example.com/users/${userId}`);
  return response.json();
});

const userSlice = createSlice({
  name: "user",
  initialState: {
    data: null,
    status: "idle", // 'idle' | 'loading' | 'succeeded' | 'failed'
    error: null,
  },
  reducers: {
    clearUser: (state) => {
      state.data = null;
      state.status = "idle";
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchUser.pending, (state) => {
        state.status = "loading";
      })
      .addCase(fetchUser.fulfilled, (state, action) => {
        state.status = "succeeded";
        state.data = action.payload;
      })
      .addCase(fetchUser.rejected, (state, action) => {
        state.status = "failed";
        state.error = action.error.message;
      });
  },
});

export const { clearUser } = userSlice.actions;
export default userSlice.reducer;

// Using in component
function UserProfile({ userId }) {
  const dispatch = useDispatch();
  const { data, status, error } = useSelector((state) => state.user);

  useEffect(() => {
    dispatch(fetchUser(userId));
  }, [userId, dispatch]);

  if (status === "loading") return <p>Loading...</p>;
  if (status === "failed") return <p>Error: {error}</p>;
  if (!data) return null;

  return (
    <div>
      <h2>{data.name}</h2>
      <p>{data.email}</p>
    </div>
  );
}
```

---

## 9. RTK Query

Redux Toolkit's data fetching and caching solution, eliminating most data-fetching boilerplate.

```jsx
// api.js
import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";

export const api = createApi({
  reducerPath: "api",
  baseQuery: fetchBaseQuery({ baseUrl: "https://api.example.com" }),
  tagTypes: ["Post", "User"],
  endpoints: (builder) => ({
    // GET request
    getPosts: builder.query({
      query: () => "/posts",
      providesTags: ["Post"],
    }),

    // GET with params
    getPost: builder.query({
      query: (id) => `/posts/${id}`,
      providesTags: (result, error, id) => [{ type: "Post", id }],
    }),

    // POST request
    createPost: builder.mutation({
      query: (newPost) => ({
        url: "/posts",
        method: "POST",
        body: newPost,
      }),
      invalidatesTags: ["Post"],
    }),

    // PUT request
    updatePost: builder.mutation({
      query: ({ id, ...patch }) => ({
        url: `/posts/${id}`,
        method: "PUT",
        body: patch,
      }),
      invalidatesTags: (result, error, { id }) => [{ type: "Post", id }],
    }),

    // DELETE request
    deletePost: builder.mutation({
      query: (id) => ({
        url: `/posts/${id}`,
        method: "DELETE",
      }),
      invalidatesTags: ["Post"],
    }),
  }),
});

export const {
  useGetPostsQuery,
  useGetPostQuery,
  useCreatePostMutation,
  useUpdatePostMutation,
  useDeletePostMutation,
} = api;

// store.js
import { configureStore } from "@reduxjs/toolkit";
import { api } from "./api";

export const store = configureStore({
  reducer: {
    [api.reducerPath]: api.reducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(api.middleware),
});

// Using in components
function PostsList() {
  const { data: posts, error, isLoading, refetch } = useGetPostsQuery();

  if (isLoading) return <p>Loading...</p>;
  if (error) return <p>Error: {error.message}</p>;

  return (
    <div>
      <button onClick={refetch}>Refresh</button>
      {posts.map((post) => (
        <PostItem key={post.id} post={post} />
      ))}
    </div>
  );
}

function PostItem({ post }) {
  const [deletePost, { isLoading }] = useDeletePostMutation();

  const handleDelete = async () => {
    try {
      await deletePost(post.id).unwrap();
      alert("Post deleted!");
    } catch (err) {
      alert("Failed to delete post");
    }
  };

  return (
    <div>
      <h3>{post.title}</h3>
      <p>{post.body}</p>
      <button onClick={handleDelete} disabled={isLoading}>
        {isLoading ? "Deleting..." : "Delete"}
      </button>
    </div>
  );
}

function CreatePost() {
  const [title, setTitle] = useState("");
  const [body, setBody] = useState("");
  const [createPost, { isLoading }] = useCreatePostMutation();

  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      await createPost({ title, body }).unwrap();
      setTitle("");
      setBody("");
      alert("Post created!");
    } catch (err) {
      alert("Failed to create post");
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        value={title}
        onChange={(e) => setTitle(e.target.value)}
        placeholder="Title"
      />
      <textarea
        value={body}
        onChange={(e) => setBody(e.target.value)}
        placeholder="Body"
      />
      <button type="submit" disabled={isLoading}>
        {isLoading ? "Creating..." : "Create Post"}
      </button>
    </form>
  );
}
```

**Advanced features:**

```jsx
// Polling (auto-refetch)
const { data } = useGetPostsQuery(undefined, {
  pollingInterval: 3000, // Refetch every 3 seconds
});

// Skip query conditionally
const { data } = useGetUserQuery(userId, {
  skip: !userId, // Don't fetch if no userId
});

// Transforming responses
getPosts: builder.query({
  query: () => "/posts",
  transformResponse: (response) => {
    return response.map((post) => ({
      ...post,
      formattedDate: new Date(post.createdAt).toLocaleDateString(),
    }));
  },
});

// Optimistic updates
updatePost: builder.mutation({
  query: ({ id, ...patch }) => ({
    url: `/posts/${id}`,
    method: "PUT",
    body: patch,
  }),
  async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {
    // Optimistically update cache
    const patchResult = dispatch(
      api.util.updateQueryData("getPost", id, (draft) => {
        Object.assign(draft, patch);
      })
    );
    try {
      await queryFulfilled;
    } catch {
      // Revert on error
      patchResult.undo();
    }
  },
});
```

---

## 10. Decision Making

Choose the right state management solution for your needs:

### useState

**Use when:**

- State is local to a single component
- Simple form inputs
- Toggle states, modals
- Small component-level data

**Example:** Button click counter, form validation, modal open/close state

### Lifting State Up

**Use when:**

- 2-3 sibling components need shared state
- Parent-child communication is simple
- State logic is straightforward

**Example:** Form with multiple inputs, filtering a list with controls in separate components

### Context API

**Use when:**

- State needs to be accessed by many components at different nesting levels
- You want to avoid prop drilling
- State changes infrequently (theme, auth, locale)
- Small to medium apps

**Pros:** Built into React, simple API, no extra dependencies  
**Cons:** Can cause unnecessary re-renders, not optimized for frequent updates

**Example:** User authentication, theme settings, language preferences

### Zustand

**Use when:**

- Medium-sized apps with moderate state complexity
- You want simplicity without Redux boilerplate
- Frequent state updates across multiple components
- You need middleware (persist, devtools)

**Pros:** Minimal boilerplate, great DX, fast, built-in middleware  
**Cons:** Smaller ecosystem than Redux

**Example:** Shopping cart, global UI state, user preferences, notifications

### Redux Toolkit

**Use when:**

- Large, complex applications
- Need time-travel debugging
- Complex state logic with many actions
- Team is familiar with Redux patterns
- Need robust middleware ecosystem

**Pros:** Predictable state updates, excellent devtools, large ecosystem  
**Cons:** More boilerplate than Zustand, steeper learning curve

**Example:** Enterprise apps, apps with complex business logic, apps needing undo/redo

### RTK Query

**Use when:**

- Your app heavily relies on server data
- You want automatic caching and synchronization
- Need optimistic updates
- Want to eliminate data-fetching boilerplate

**Pros:** Automatic caching, refetching, garbage collection  
**Cons:** Tightly coupled with Redux Toolkit

**Example:** CRUD applications, dashboards fetching API data, real-time data apps

---

## Quick Decision Tree

```
Does only one component need this state?
├─ YES → useState
└─ NO ↓

Do only 2-3 nearby components need it?
├─ YES → Lift state up
└─ NO ↓

Is it mostly server data (CRUD operations)?
├─ YES → RTK Query
└─ NO ↓

Is it infrequently changing global state?
├─ YES → Context API
└─ NO ↓

Is your app large and complex?
├─ YES → Redux Toolkit
└─ NO → Zustand
```

---

## Best Practices

1. **Start simple:** Always start with useState and lift state up. Only add complexity when needed.

2. **Collocate state:** Keep state as close as possible to where it's used.

3. **Avoid premature optimization:** Don't reach for global state management until prop drilling becomes painful.

4. **Separate server state from client state:** Consider using RTK Query or React Query for server data, and Zustand/Context for UI state.

5. **Use TypeScript:** All modern state management libraries have excellent TypeScript support.

6. **Keep actions simple:** Each action should do one thing well.

7. **Normalize complex state:** Store data in a flat structure with IDs rather than nested objects.

8. **Use selectors:** Create reusable selectors to compute derived state.

---

## Conclusion

State management in React is a journey. Start with useState, embrace lifting state up, use Context for simple global state, and graduate to Zustand or Redux Toolkit as your application grows. Remember: the best state management solution is the simplest one that solves your problem.
